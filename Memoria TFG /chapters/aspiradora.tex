\chapter{Ejercicio aspiadora robótica atrapa confeti}\label{chap:aspiradora}
En los siguientes capítulos se explica el proceso de desarrollo de los tres ejercicios realizados en este trabajo fin de grado. Este capítulo está dedicado al primero de ellos, este ejercicio consiste en una aspiradora robótica que atrapa confeti. En primer lugar se expone el enunciado y objetivos. En segundo lugar cómo se ha implementando y creado los modelos para la plataforma Kibotics. Finalmente se muestran unas soluciones de referencia en Python y Scratch que satisfacen el objetivo del ejercicio.


\section{Enunciado}
La finalidad de este ejercicio es hacer una aspiradora robótica que se encuentre en una habitación y que ésta sea capaz de recoger piezas de confeti cuando pase por encima. El evaluador automático que se va a realizar nos servirá para contar el confeti recogido en un tiempo determinado.

El alumno deberá programar en Scratch o en Python un algoritmo de planificación de ruta para que consiga atrapar el mayor número de confetis de la habitación en 5 minutos.

Para la visualización de este ejercicio y que los usuarios de Kibotics puedan acceder a él, se ha creado una página web en Kibotics. Gracias a esta página web, los usuarios tienen acceso a la teoría del ejercicio y  disponen de un editor y el simulador Websim necesarios para hacer el ejercicio. 

Se creó la teoría del ejercicio en HTML5 y se modificaron las plantillas que utiliza el servidor Django de Kibotics. Este ejercicio se planteó como un juego sencillo. El objetivo del usuario  es hacer un algoritmo de planificación de ruta utilizando los sensores y actuadores del robot para que cuando detecte un objeto próximo, por ejemplo una pared o una mesa, se mueva en ángulos aleatorios. 
En las siguientes Figuras podemos ver la página de teoría donde se explica el objetivo del ejercicio, los requisitos (Figura 4.1),  para explicar al alumno los diferentes algoritmos de cobertura que puede utilizar los aspiradores robóticos se ha añadido un poco de teoría(Figura  4.2) , unas pequeñas pistas y un ¿Sabías que...? (Figura 4.3) hablando de las primeras aspiradoras y cómo funcionaban. 


\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth, height=0.4\textwidth]{chapters/images/teoria1.png}
    \caption{Página de teoría enunciado y requisitos}
    \label{fig:my_label}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth, height=0.4\textwidth]{chapters/images/teoria2.png}
    \caption{Teoría}
    \label{fig:my_label}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth, height=0.4\textwidth]{chapters/images/teoria3.png}
    \caption{Pistas y ¿sabías que.. ?}
    \label{fig:my_label}
\end{figure}

Para hacer el ejercicio descrito a continuación, se utilizaron las herramientas Blender, el simulador Websim de Kibotics que contiene la tecnología A-Frame y los lenguajes JavaScript, HTML5 y JSON.

\section{Modelo aspiradora}

El robot  propuesto en este ejercicio es una aspiradora robótica. Se crearon varios prototipos en Blender  hasta que se llegó al modelo final que podemos ver en la Figura 4.4. Su diseño está inspirado en los aspiradores robóticos más conocidos. El logo que aporta color al aspirador pertenece a la asociación JdeRobot \footnote{https://jderobot.github.io/}, pilar fundamental en el desarrollo de la plataforma Kibotics.
 
 \begin{figure}[H]
  \begin{subfigure}[b]{0.5\textwidth}
  \centering
    \includegraphics[width=0.95\textwidth, height=0.7\textwidth]{chapters/images/roombablender.png}
    \caption{}
    \label{fig:f1}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.5\textwidth}
  \centering
    \includegraphics[width=0.95\textwidth, height=0.7\textwidth]{chapters/images/roombablender2.png}
	\caption{}    
    \label{fig:f2}
 
  \end{subfigure}
  \caption{Modelo de la aspiradora robótica  realizado en Blender.}
\end{figure}

El simulador Websim analiza (\textit{parsea}) ficheros JSON para formar mundos con la tecnología A-Frame. De esta forma es sencillo crear los objetos con pares \textit{``atributo":valor}. A continuación podemos ver cómo se define el id robot del nuevo robot, se importa el gltf-model que hemos creado en Blender de la aspiradora y se le asignan otros atributos como la posición, escala y rotación del robot. El \textit{dynamic-body} nos facilita el movimiento del robot y el atributo \textit{collide} asigna una malla de colisión cilíndirca para que la aspiradora pueda chocarse con los demás elementos del mundo usando físicas de A-Frame y todo sea mucho más realista.


\begin{lstlisting}
 
           "tag": "a-robot",
            "attr": {
                "id": "a-pibot",
                "gltf-model":"/static/websim/assets/models/roombajderbotgrey.gltf",
                "scale": { "x":2, "y":2, "z":2},
                "position": { "x":0, "y":4, "z":30},
                "rotation": { "x":0, "y":90, "z":0},
                "dynamic-body":{"mass": 10, "shape":"none",
                "shape__handle":{"shape": "cylinder",
                         "height": 0.36,
                         "radiusTop": 1.2,
                         "radiusBottom": 1.2,
                         "offset": "-0.1 0.2 -0.55"},
                "collide":{}

            },
\end{lstlisting}


\section{Confeti y absorcción}
El modelo de confeti se creó con la etiqueta \textit{a-cylinder} de A-Frame para hacer pruebas de absorción en JavaScript.
Las pruebas de absorción se estudiaron tanto en función de la posición como por colisión. En este vídeo \footnote{https://www.youtube.com/watch?v=xkC\_qHXKUDs} se puede ver el primer prototipo con colisión y en este otro por posición \footnote{https://www.youtube.com/watch?v=If2XMcr1ci4}, al ser un efecto más parecido a lo que ocurre en la realidad se eligió implementar este ejercicio con la absorción basada en posición (ver Figura 4.5).

\begin{figure}[H]
  \begin{subfigure}[b]{0.5\textwidth}
  \centering
    \includegraphics[width=0.8\textwidth, height=0.5\textwidth]{chapters/images/prototiporoomba.png}
    \caption{Modelos aspiradora y confeti en A-Frame}
    \label{fig:f1}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.5\textwidth}
  \centering
    \includegraphics[width=0.8\textwidth, height=0.5\textwidth]{chapters/images/prototiporoomba2.png}
	\caption{Confeti invisible}    
    \label{fig:f2}
 
  \end{subfigure}
  \caption{Absorción por posición, el confeti es invisble cuando el robot pasa por encima.}
\end{figure}

El confeti no se crea desde el fichero de configuración dado que se tendrían que crear uno a uno  todos los confetis y se extendería demasiado el fichero. Lo que se ha hecho es que, una vez esta cargado el mundo en el navegador del usuario, usando JavaScript, creamos dinámicamente todos los confetis.

Para hacerlo de esta forma, primero se generó un programa para fijar aleatoriamente las posiciones de los confetis en el mundo, así los confetis quedan esparcidos por la habitación y todos los alumnos cuentan con el mismo escenario. Estas posiciones x, y, z de los confetis se guardaron en otro fichero JSON llamado \textit{data.json}. En total el escenario está formado por 100 confetis de colores. El color de cada confeti se elige aleatoriamente cuando se crean desde JavaScript .

Parte del fichero data.json: 
\begin{lstlisting}
  data = '[{"x":-39,"y":0,"z":-14},
                {"x":7,"y":0,"z":-11},
                {"x":-6,"y":0,"z":-9},
                {"x":-33,"y":0,"z":28},
                {"x":-11,"y":0,"z":41},
                {"x":-11,"y":0,"z":-13},
                {"x":19,"y":0,"z":23},
                {"x":19,"y":0,"z":-30},
                {"x":-4,"y":0,"z":-27},
                {"x":25,"y":0,"z":20},
                ....]'
 \end{lstlisting}


Para leer el fichero \textit{data.json} se utiliza esté código en la plantilla HTML del ejercicio.
\begin{lstlisting}
 <script type="text/javascript" src="{\% static '/data.json' \%}"></script > 
 \end{lstlisting}


En el siguiente código podemos ver cómo se crea el confeti con la función \textit{document\.createElement(`a-cylinder')}. Una vez creado se le asignan los atributos con la función  \textit{setAttribute}.  El id es confeti más un número  n, n es un número de 0-99 que se le asigna para crear 100 confetis diferentes (Ejemplo de id del confeti número 50   id=``confeti50"). Además se le asigna los atributos posición, con la posición correspondiente que se lee del \textit{data.json}, el color que es  aleatorio, como es un cilindro, se define la altura y radio del confeti.
Los confetis no cuentan con malla de colisión para que el aspirador pueda pasar por encima de ellos y absorberlos de una forma más natural.
Estas son las funciones necesarias para la creación de las piezas de confeti: 
\begin{lstlisting}

function getRandomColor() {
    var letters = '0123456789ABCDEF';
    var color = '#';
    for (var i = 0; i < 6; i++) {
      color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
}

document.addEventListener('robot-loaded', (evt)=>{
    localRobot = evt.detail;
    console.log(localRobot);

    var sceneEl = document.querySelector('a-scene');

    // CREATE CONFETI
    var n = 0;
    var n_confetis = 99;
    score = 0;
    var array = JSON.parse(data);

    for ( n = 0; n <=n_confetis ; n++) {
      var c = document.createElement('a-cylinder');
      var num_conf="confeti"+ String(n)
      c.setAttribute('id', num_conf);
      pos = {x:array[n].x, y:0,z:array[n].z}
    
      c.setAttribute('position',pos);
    
      var color = getRandomColor();
      c.setAttribute('color', color);
      c.setAttribute('height', "0.25");
      c.setAttribute('radius', 1);
      sceneEl.appendChild(c);
}
\end{lstlisting}

La absorción se implementó con JavaScript. Se utilizó la función setInterval. Esta función ejecuta las funciones que estén definidas dentro, cada un cierto periodo de tiempo indefinidamente.
Se ha establecido que cada 25ms este programa comprueba la distancia entre la aspiradora robótica y cada uno de los confetis. La posición del robot es su centro de masas, por eso se  utilizó la distancia euclídea para calcular la distancia entre el centro del robot y el centro del confeti n, si esta distancia d es menor o igual a 2, el confeti n cambia su atributo 'visible' a false. 

\begin{lstlisting}

roomba=sceneEl.querySelector('#a-pibot')

 setInterval(function(){

       for ( n = 0; n <=n_confetis ; n++) {
        d = Math.sqrt(Math.pow((array[n].z-roomba.getAttribute('position').z), 2)+Math.pow((array[n].x-roomba.getAttribute('position').x), 2));

       if ( d <= 2 ){
         num_conf="#confeti"+ String(n)
         confeti=sceneEl.querySelector(num_conf)
         confeti.setAttribute('visible', false);
         }
        }
      }
    }, 25);
 });
\end{lstlisting}

\section{Modelos del mundo}
Una vez se consiguió simular la absorción de los confetis como hemos visto en el apartado anterior, se crearon nuevos muebles con Blender (ver Figuras 4.6 y 4.7). De esta forma se mejoró el escenario para que fuera una habitación de una casa (ver Figura 4.8).
\begin{figure}[H]
  \begin{subfigure}[b]{0.5\textwidth}
  \centering
    \includegraphics[width=0.95\textwidth, height=0.6\textwidth]{chapters/images/silla.png}
    \caption{Modelo silla}
    \label{fig:f1}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.5\textwidth}
  \centering
    \includegraphics[width=0.95\textwidth, height=0.6\textwidth]{chapters/images/mesa.png}
	\caption{Modelo mesa}    
    \label{fig:f2}
 
  \end{subfigure}
  \caption{Modelos en Blender}
\end{figure}

\begin{figure}[H]
  \centering
 \includegraphics[width=0.7\textwidth]{chapters/images/sofa.png}
  \caption{Modelo sofá en Blender}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth, height=0.4\textwidth]{chapters/images/habitacioncon.png}
\caption{Habitación amueblada}
\end{figure}

Estos objetos se añadieron en el fichero de configuración json del ejercicio definiendo su id, gltf-model, la posición y la escala. El código que se muestra a continuación pertenece a la creación de la mesa pero  la estructura  de todos los elementos añadidos es la misma: 
\begin{lstlisting}
{
          "tag": "a-entity",
          "attr": {
              "id": "model-table",
              "gltf-model":"/static/websim/assets/models/mesa.gltf",
              "position":{"x":40, "y":0,"z":0},
              "scale": {"x":3,"y":3,"z":3}

          }
      },
\end{lstlisting}

Para que el ejercicio tenga mayor dificultad se introdujeron 2 pelotas con movimiento. Para conseguir este movimiento había dos posibilidades: animación desde Blender o Animación desde A-Frame. 
En el vídeo \footnote{https://www.youtube.com/watch?v=1JPb3Mw8638}  se puede ver cómo hacer una animación no lineal sencilla en Blender. Para poder usar animaciónes de Blender en Websim es necesario que sean animaciones no lineales. Estudiando ambas opciones, se optó por la animación en A-Frame desde el fichero de configuración que era el método ideal para Websim, de esta forma dejamos toda la creación de las pelotas, asignación de texturas, posición y  animación definido en la configuración.

Para animar un objeto desde A-Frame añadimos el atributo \textit{``animation"} y completamos los valores que sean necesarios como desde dónde a dónde quieres que se mueva  el objeto o el tiempo que quieres que tarde en hacer esa animación. Las dos pelotas tienen estos atributos pero con sus respectivos valores, por ejemplo en el siguiente código se puede ver como se define la animación en diagonal de la pelota de baloncesto: 
\begin{lstlisting}
  {
            "tag": "a-sphere",
            "attr": {
                "id":"basketball",
                "position": { "x":-40, "y":1.5, "z":-40 },
                "rotation": { "x":0, "y":0, "z":0 },
                "radius": 1.5,
                "src":"#basketball",
                "static-body": {
                    "mass": 2
                },              
	           "class":"collidable",
                "animation": "property: position; from: -40 1.5 -40 ;to: 40 1.5 40; dir: alternate; dur: 10000; loop: true"

            }
        },

\end{lstlisting}



\section{Evaluador automático}
Para contar el número de confetis que es capaz de recoger un usuario en un periodo de tiempo se creó un evaluador automático. Este evaluador automático se introdujo dentro de la absorción. Como en la parte de absorción se calcula la distancia euclídea, cada vez que d es menor o igual a 2 se suma un punto e indica que el confeti n ha sido  ``absorbido" por el aspirador. La puntuación máxima es de 100, dado que depende del número de confetis 0-99. También se establece una cuenta atrás de 5:00 minutos. Una vez acabado el tiempo (Tiempo 00:00), aunque la aspiradora pase por encima de otros confetis visibles, éstos no serán absorbidos ni se aumentará el contador del evaluador.


En el siguiente código podemos ver todo lo necesario para la comprobación de las posiciones del confeti para la absorción y la implementación de la puntuación del evaluador. En la Figura 4.9 se muestra cómo se visualiza en la página web del ejercicio.

\begin{lstlisting}

startEvaluator = () => {
  started = true;
}
roomba=sceneEl.querySelector('#a-pibot')

 setInterval(function(){
       //console.log("Roomba",roomba.getAttribute('position').z);
      // console.log("Confeti",confeti.getAttribute('position'));
       //console.log("Confeti",confeti.getAttribute('position').z)
       for ( n = 0; n <=n_confetis ; n++) {
        d = Math.sqrt(Math.pow((array[n].z-roomba.getAttribute('position').z), 2)+Math.pow((array[n].x-roomba.getAttribute('position').x), 2));

       if ( d <= 2 ){
         num_conf="#confeti"+ String(n)
         confeti=sceneEl.querySelector(num_conf)
         if (confeti.getAttribute('visible') == true) {
	      
	      var counter= document.getElementById('time').innerHTML;
		// Tiempo: 00:00	
	      if((counter[8] =='0') && (counter[9]=='0') && (counter[11]=='0') && (counter[12]== '0')){      
		score = score;
		}else{
		score+=1;
		document.getElementById('confeti_recogido').innerHTML = "Confetti recogido: "+ score;
		}
         }
         confeti.setAttribute('visible', false);
        }
      }
	
    }, 25);
 });
\end{lstlisting}

 \begin{figure}[H]
  \centering
 \includegraphics[width=0.35\textwidth]{chapters/images/evaluadoraspiradora.png}
  \caption{Evaluador automático aspiradora robótica}
\end{figure}
\section{Solución de referencia}

Hay muchas formas diferentes  de resolver este ejercicio, en este apartado se proponen dos soluciones en los dos lenguajes que nos proporciona Kibotics. En la Figura 4.10 se muestra una solución realizada en Scratch y en la Figura 4.11 una para Python.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth, height=0.4\textwidth]{chapters/images/solucionroombascratch.png}
    \caption{Solución en Scratch }
    \label{fig:my_label}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth, height=0.4\textwidth]{chapters/images/solucionroombapython.png}
    \caption{Solución en Python}
    \label{fig:my_label}
\end{figure}

Este ejercicio ya está disponible en la plataforma Kibotics. También se han realizado dos vídeos promocionales para presentar el nuevo ejercicio de la plataforma con los códigos que se han mostrado en las Figuras 5.9 y 5.10. Estos vídeos \footnote{https://www.youtube.com/watch?v=5Q0TmwunYWY} \footnote{https://www.youtube.com/watch?v=Twc9wsPFjaY} sirven de ejemplo y motivación para los alumnos que vayan a realizarlo.